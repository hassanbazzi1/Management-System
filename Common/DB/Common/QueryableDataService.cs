using Common.API.Models;using Microsoft.EntityFrameworkCore;namespace Common.DB.Common;public class QueryableDataService<T,F> : DbDataDataService<T,F> where T:DbContext{    public QueryableDataService(T context) : base(context)    {    }    public IQueryable<F> ApplyKeysetPaging(DataQueryOptions queryOptions,IQueryable<F> baseData,string? key=null)    {        // TODO: Add ascending descending option if needed        return baseData.OrderBy(c => EF.Property<int>(c, key ?? "id")).Where(c => EF.Property<int>(c, key ?? "id") > queryOptions.PageOptions.LastId).Take(queryOptions.PageOptions.Limit.Value);    }        public IQueryable<F> ApplyOffsetPaging(DataQueryOptions queryOptions,IOrderedQueryable<F> baseData)    {        return baseData.Skip(queryOptions.PageOptions.Position.Value).Take(queryOptions.PageOptions.Limit.Value);    }    public IQueryable<F> ApplyFilters(DataQueryOptions queryOptions,IQueryable<F> baseData, List<string>? defaultFilterColumns=null)    {        if (queryOptions.FilterOptions.IncludedFields == null || queryOptions.FilterOptions.IncludedFields.Count > 0)        {            if(defaultFilterColumns != null && defaultFilterColumns.Count > 0)                queryOptions.FilterOptions.IncludedFields = defaultFilterColumns;            return baseData;        }        // TODO: Add support for search int and date fields        foreach (var field in queryOptions.FilterOptions.IncludedFields)        {            var type = GetTypeOfEntity(field);            if (type != null)            {                switch (type)                {                    case Type t when t == typeof(string):                        baseData = baseData.Where(e=>EF.Functions.ILike(EF.Property<string>(e, field),"%" + queryOptions.FilterOptions.SearchText + "%"));                        break;                    // TODO: Add support for searching other data types                    case Type t when t == typeof(DateTime):                        break;                    case Type t when t == typeof(int):                        break;                    case Type t when t == typeof(long):                        break;                    case Type t when t == typeof(bool):                        break;                    case Type t when t == typeof(double):                        break;                    case Type t when t == typeof(float):                        break;                    case Type t when t == typeof(float):                        break;                    default:                        break;                }            }            baseData = baseData.Where(c => EF.Functions.ILike(EF.Property<string>(c, field), "%" + queryOptions.FilterOptions.SearchText + "%"));        }        return baseData;    }        public IOrderedQueryable<F> ApplySorting(DataQueryOptions queryOptions,IQueryable<F> baseData)    {        IOrderedQueryable<F> sortResults = null;        int i = 0;        foreach (var kvp in queryOptions.SortOptions.OrderBy)        {            bool isOrderAscending = kvp.Value.Equals("asc");            bool isAppend = (i++ >0);            var type = GetTypeOfEntity(kvp.Key);            if (type != null)            {                switch (type)                {                    case Type t when t == typeof(DateTime):                        sortResults = OrderBySetting<DateTime,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(string):                        sortResults = OrderBySetting<string,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(int):                        sortResults = OrderBySetting<int,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(long):                        sortResults = OrderBySetting<long,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(bool):                        sortResults = OrderBySetting<bool,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(double):                        sortResults = OrderBySetting<double,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    case Type t when t == typeof(float):                        sortResults = OrderBySetting<float,F>.Create(kvp.Key,isOrderAscending,sortResults,baseData,isAppend).AddOrderBy();                        break;                    default:                        i--;                        break;                }            }        }                return sortResults;    }            public IQueryable<F> ApplyDataQuery(DataQueryOptions queryOptions, IQueryable<F> baseData,string? defaultOrderKey=null,List<string>? defaultFilterColumns=null)    {        if (queryOptions.HasValidFilterOptions())        {            baseData = ApplyFilters(queryOptions,baseData,defaultFilterColumns);        }                if (queryOptions.HasValidPageOptions())        {            if (queryOptions.HasValidSortOptions())            {                // Use offset paging with custom sort                return ApplyOffsetPaging(queryOptions,ApplySorting(queryOptions,baseData));            }            else if(queryOptions.IsKeysetPagination())            {                // Use keyset paging if no sort specified                return ApplyKeysetPaging(queryOptions,baseData,defaultOrderKey);            }            else            {                // No keyset paging and no sorting. Apply default offset sorting and default pagination                // TODO: Customize per use case                // Use default sort                queryOptions.SortOptions = new SortOptions                 {                     OrderBy = new()                    {                        {defaultOrderKey,"desc"}                    }                 };                                return ApplyOffsetPaging(queryOptions,ApplySorting(queryOptions,baseData));            }        }        else        {            // No paging, only sort            if (queryOptions.HasValidSortOptions())            {                 // Custom sort with no paging                return ApplySorting(queryOptions, baseData);            }            else            {                // Default sort with no paging                queryOptions.SortOptions = new SortOptions                 {                     OrderBy = new()                    {                        {defaultOrderKey,"desc"}                    }                 };                                return ApplySorting(queryOptions, baseData);            }        }    }}internal class OrderBySetting<T,F>{    private string orderPropertyName;    private bool isOrderAscending;    private IOrderedQueryable<F> sortResults;    private IQueryable<F> baseData;    private bool isAppend;    public static OrderBySetting<T,F> Create(string orderPropertyName, bool isOrderAscending, IOrderedQueryable<F> sortResults, IQueryable<F> baseData, bool isAppend)    {        return new OrderBySetting<T, F>        {            orderPropertyName = orderPropertyName,            isOrderAscending = isOrderAscending,            sortResults = sortResults,            baseData = baseData,            isAppend = isAppend        };    }    public IOrderedQueryable<F> AddOrderBy()    {        if (!isAppend)            return isOrderAscending ? baseData.OrderBy(c => EF.Property<T>(c, orderPropertyName)) : baseData.OrderByDescending(c => EF.Property<T>(c, orderPropertyName));        else            return isOrderAscending ? sortResults.ThenBy(c => EF.Property<T>(c, orderPropertyName)) : sortResults.ThenByDescending(c => EF.Property<T>(c, orderPropertyName));    }}